Welcome back to the **Go Lang Learning** blog.

Let's start with **Methods** in Go language.

There are no classes in Go. That's where methods kick in to rescue us.
A method is a specific receiver argument to a function. Between the func keyword and the method name, the receiver appears in its own parameter list.

For example,

```
package main

import "fmt"

type Student struct {
    Name string
    Semester  int
}

func (s Student) GetStudentDetails() {
    fmt.Printf("Name of the student is: %s, and currently in: %d\n semester", p.Name, p.Semester)
}

func main() {
    s1 := Student{Name: "Uday", Semester: 3}
    s1.GetStudentDetails()
}

```

In this example, we define a type Student with two fields: Name and Semester. We then define a method GetStudentDetails associated with the Student type. This method takes no arguments, but it has access to the fields of the Student type through the receiver s.

In the main function, we create a new Student object s1 and call the GetStudentDetails method on it. 

The output of the program will be:

```
Name of the student is: Uday, and currently in: 3 semester.
```

You can declare methods with pointer receivers.

This indicates that the receiver type is represented by the literal syntax *T for some type T. (In addition, T cannot be a pointer like *int.)

Methods with pointer receivers have the ability to change the value to which the receiver points. Pointer receivers are more prevalent than value receivers because methods frequently need to adjust their receiver.

```
type Counter struct {
    count int
}

func (c *Counter) Increment() {
    c.count++
}

func main() {
    c := Counter{count: 0}
    c.Increment()
    fmt.Println(c.count) 
}
```

The above print statements gives 1 as output.

There are various ways to define and use methods in Go lang which made me really confusing and **challenging**. 

I will show you some different ways to create and how they behave. Understanding there behaviours and how to implement with respect to each case was
a hague task on me.

But, anyways I learned them from Go lang playground by playing out with their hands on code and I will show you some good examples below.

When the receivers are pointers,
```
package main

import (
	"fmt"
	"math"
)

type Point struct {
	X, Y float64
}

func (p Point) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (p *Point) Scale(f float64) {
	p.X = p.X * f
	p.Y = p.Y * f
}

func main() {
	p := Vertex{3, 4}
	p.Scale(10)
	fmt.Println(p.Abs())
}

```

If we run this, then we are going to get 50 as output because of the pointer as an input to Scale function. If it had not been a pointer then the output
doest not get multiplied by 10 and gives 5 as output. 

It felt **challenging** at the start but there are some more examples below for you which makes your life easier.

**Methods and pointer indirection**

This was also bit challengine but lets see how well can I explain you people.

